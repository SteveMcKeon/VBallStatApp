diff --git a/VBallAppNotes.txt b/VBallAppNotes.txt
index 5edcff5..b183174 100644
--- a/VBallAppNotes.txt
+++ b/VBallAppNotes.txt
@@ -21,7 +21,6 @@ REFACTOR
 EditableCell suggestions only work on enter and not tab.
 UPDATE TO YES/NO INSTEAD OF TRUE/FALSE for plebians
 Supabase Auth session missing.
-use tus.io for streaming the uploads
 Sometimes seeking doesn't work on new videos. weird.
 Doesn't refresh DBStats until Exit Edit mode?
 Don't let "Select file" text be selectable on upload modal
diff --git a/frontend/package-lock.json b/frontend/package-lock.json
index 6dc37cd..2944b43 100644
--- a/frontend/package-lock.json
+++ b/frontend/package-lock.json
@@ -8,6 +8,9 @@
       "name": "volleyball-tracker_frontend",
       "version": "1.0.0",
       "dependencies": {
+        "@dnd-kit/core": "^6.3.1",
+        "@dnd-kit/sortable": "^10.0.0",
+        "@dnd-kit/utilities": "^3.2.2",
         "@supabase/supabase-js": "^2.42.0",
         "@tailwindcss/postcss": "^4.1.11",
         "@tailwindcss/vite": "^4.1.11",
@@ -342,6 +345,59 @@
         "node": ">=6.9.0"
       }
     },
+    "node_modules/@dnd-kit/accessibility": {
+      "version": "3.1.1",
+      "resolved": "https://registry.npmjs.org/@dnd-kit/accessibility/-/accessibility-3.1.1.tgz",
+      "integrity": "sha512-2P+YgaXF+gRsIihwwY1gCsQSYnu9Zyj2py8kY5fFvUM1qm2WA2u639R6YNVfU4GWr+ZM5mqEsfHZZLoRONbemw==",
+      "license": "MIT",
+      "dependencies": {
+        "tslib": "^2.0.0"
+      },
+      "peerDependencies": {
+        "react": ">=16.8.0"
+      }
+    },
+    "node_modules/@dnd-kit/core": {
+      "version": "6.3.1",
+      "resolved": "https://registry.npmjs.org/@dnd-kit/core/-/core-6.3.1.tgz",
+      "integrity": "sha512-xkGBRQQab4RLwgXxoqETICr6S5JlogafbhNsidmrkVv2YRs5MLwpjoF2qpiGjQt8S9AoxtIV603s0GIUpY5eYQ==",
+      "license": "MIT",
+      "dependencies": {
+        "@dnd-kit/accessibility": "^3.1.1",
+        "@dnd-kit/utilities": "^3.2.2",
+        "tslib": "^2.0.0"
+      },
+      "peerDependencies": {
+        "react": ">=16.8.0",
+        "react-dom": ">=16.8.0"
+      }
+    },
+    "node_modules/@dnd-kit/sortable": {
+      "version": "10.0.0",
+      "resolved": "https://registry.npmjs.org/@dnd-kit/sortable/-/sortable-10.0.0.tgz",
+      "integrity": "sha512-+xqhmIIzvAYMGfBYYnbKuNicfSsk4RksY2XdmJhT+HAC01nix6fHCztU68jooFiMUB01Ky3F0FyOvhG/BZrWkg==",
+      "license": "MIT",
+      "dependencies": {
+        "@dnd-kit/utilities": "^3.2.2",
+        "tslib": "^2.0.0"
+      },
+      "peerDependencies": {
+        "@dnd-kit/core": "^6.3.0",
+        "react": ">=16.8.0"
+      }
+    },
+    "node_modules/@dnd-kit/utilities": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/@dnd-kit/utilities/-/utilities-3.2.2.tgz",
+      "integrity": "sha512-+MKAJEOfaBe5SmV6t34p80MMKhjvUz0vRrvVJbPT0WElzaOJ/1xs+D+KDv+tD/NE5ujfrChEcshd4fLn0wpiqg==",
+      "license": "MIT",
+      "dependencies": {
+        "tslib": "^2.0.0"
+      },
+      "peerDependencies": {
+        "react": ">=16.8.0"
+      }
+    },
     "node_modules/@emotion/babel-plugin": {
       "version": "11.13.5",
       "resolved": "https://registry.npmjs.org/@emotion/babel-plugin/-/babel-plugin-11.13.5.tgz",
@@ -1580,12 +1636,12 @@
       "license": "MIT"
     },
     "node_modules/@types/node": {
-      "version": "24.1.0",
-      "resolved": "https://registry.npmjs.org/@types/node/-/node-24.1.0.tgz",
-      "integrity": "sha512-ut5FthK5moxFKH2T1CUOC6ctR67rQRvvHdFLCD2Ql6KXmMuCrjsSsRI9UsLCm9M18BMwClv4pn327UvB7eeO1w==",
+      "version": "24.2.0",
+      "resolved": "https://registry.npmjs.org/@types/node/-/node-24.2.0.tgz",
+      "integrity": "sha512-3xyG3pMCq3oYCNg7/ZP+E1ooTaGB4cG8JWRsqqOYQdbWNY4zbaV0Ennrd7stjiJEFZCaybcIgpTjJWHRfBSIDw==",
       "license": "MIT",
       "dependencies": {
-        "undici-types": "~7.8.0"
+        "undici-types": "~7.10.0"
       }
     },
     "node_modules/@types/parse-json": {
@@ -2132,9 +2188,9 @@
       "license": "MIT"
     },
     "node_modules/electron-to-chromium": {
-      "version": "1.5.194",
-      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.194.tgz",
-      "integrity": "sha512-SdnWJwSUot04UR51I2oPD8kuP2VI37/CADR1OHsFOUzZIvfWJBO6q11k5P/uKNyTT3cdOsnyjkrZ+DDShqYqJA==",
+      "version": "1.5.195",
+      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.195.tgz",
+      "integrity": "sha512-URclP0iIaDUzqcAyV1v2PgduJ9N0IdXmWsnPzPfelvBmjmZzEy6xJcjb1cXj+TbYqXgtLrjHEoaSIdTYhw4ezg==",
       "dev": true,
       "license": "ISC"
     },
@@ -4107,6 +4163,12 @@
       "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw==",
       "license": "MIT"
     },
+    "node_modules/tslib": {
+      "version": "2.8.1",
+      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
+      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
+      "license": "0BSD"
+    },
     "node_modules/tus-js-client": {
       "version": "4.3.1",
       "resolved": "https://registry.npmjs.org/tus-js-client/-/tus-js-client-4.3.1.tgz",
@@ -4140,9 +4202,9 @@
       }
     },
     "node_modules/undici-types": {
-      "version": "7.8.0",
-      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-7.8.0.tgz",
-      "integrity": "sha512-9UJ2xGDvQ43tYyVMpuHlsgApydB8ZKfVYTsLDhXkFL/6gfkp+U8xTGdh8pMJv1SpZna0zxG1DwsKZsreLbXBxw==",
+      "version": "7.10.0",
+      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-7.10.0.tgz",
+      "integrity": "sha512-t5Fy/nfn+14LuOc2KNYg75vZqClpAiqscVvMygNnlsHBFpSXdJaYtXMcdNLpl/Qvc3P2cB3s6lOV51nqsFq4ag==",
       "license": "MIT"
     },
     "node_modules/unpipe": {
diff --git a/frontend/package.json b/frontend/package.json
index d84903f..d6c20fb 100644
--- a/frontend/package.json
+++ b/frontend/package.json
@@ -3,8 +3,11 @@
   "version": "1.0.0",
   "scripts": {
     "dev": "vite --host"
-  },  
+  },
   "dependencies": {
+    "@dnd-kit/core": "^6.3.1",
+    "@dnd-kit/sortable": "^10.0.0",
+    "@dnd-kit/utilities": "^3.2.2",
     "@supabase/supabase-js": "^2.42.0",
     "@tailwindcss/postcss": "^4.1.11",
     "@tailwindcss/vite": "^4.1.11",
diff --git a/frontend/src/components/DBStats.jsx b/frontend/src/components/DBStats.jsx
index c1428f8..e4cf86d 100644
--- a/frontend/src/components/DBStats.jsx
+++ b/frontend/src/components/DBStats.jsx
@@ -558,8 +558,8 @@ const DBStats = ({
                     toggleGameField('hastimestamps', value);
                   }}
                 >
-                  <option value="true">True</option>
-                  <option value="false">False</option>
+                  <option value="true">Yes</option>
+                  <option value="false">No</option>
                 </select>
               </div>
               <div className="flex justify-between items-center w-full">
@@ -575,8 +575,8 @@ const DBStats = ({
                     toggleGameField('isscored', value);
                   }}
                 >
-                  <option value="true">True</option>
-                  <option value="false">False</option>
+                  <option value="true">Yes</option>
+                  <option value="false">No</option>
                 </select>
               </div>
             </div>
diff --git a/frontend/src/components/GameSelector.jsx b/frontend/src/components/GameSelector.jsx
index 9d9ff88..8b1437a 100644
--- a/frontend/src/components/GameSelector.jsx
+++ b/frontend/src/components/GameSelector.jsx
@@ -1,4 +1,4 @@
-import React, { useState, useEffect } from 'react';
+import React, { useState, useEffect, useRef } from 'react';
 import StyledSelect from './StyledSelect';
 import UploadGameModal from './UploadGameModal';
 import supabase from '../supabaseClient';
@@ -9,50 +9,7 @@ const getStatusColor = (game) => {
   return 'red';
 };
 
-const GameSelector = ({ games, onChange, value, videoPlayerRef, teamName }) => {
-  const [showUploadModal, setShowUploadModal] = useState(false);
-  const [incompleteUploadData, setIncompleteUploadData] = useState(null);
-  const [currentUserId, setCurrentUserId] = useState(null);
-
-  useEffect(() => {
-    const fetchSessionAndScanUploads = async () => {
-      const { data: { session }, error } = await supabase.auth.getSession();
-      if (error || !session) {
-        console.error('Failed to retrieve user session');
-        return;
-      }
-
-      const userId = session.user.id;
-      setCurrentUserId(userId);
-
-      const incompleteUploads = [];
-      for (let i = 0; i < localStorage.length; i++) {
-        const key = localStorage.key(i);
-        if (key && key.startsWith('tus::')) {
-          try {
-            const uploadData = JSON.parse(localStorage.getItem(key));
-            if (uploadData?.metadata?.user_id === userId) {
-              incompleteUploads.push({ key, ...uploadData });
-            }
-          } catch (e) {
-            console.error('Error parsing tus entry:', e);
-          }
-        }
-      }
-
-      if (incompleteUploads.length > 0) {
-        const latestUpload = incompleteUploads.sort((a, b) => 
-          new Date(b.creationTime) - new Date(a.creationTime)
-        )[0];
-
-        setIncompleteUploadData(latestUpload.metadata);
-        setShowUploadModal(true);
-      }
-    };
-
-    fetchSessionAndScanUploads();
-  }, [teamName]);
-  
+const GameSelector = ({ games, onChange, value, videoPlayerRef, teamName, currentUserId, isUploadModalOpen, setIsUploadModalOpen, setResumeSilently, resumeSilently  }) => {
   const processedGames = games.filter((game) => game.processed);
   const options = processedGames.map((game) => ({
     value: game.id,
@@ -69,15 +26,24 @@ const GameSelector = ({ games, onChange, value, videoPlayerRef, teamName }) => {
     value: 'upload-new',
     label: <em>Upload New Game...</em>,
   });
-
+  
+  const modalRef = useRef();
+  
   const handleChange = (selected) => {
     if (selected.value === 'upload-new') {
-      setShowUploadModal(true);
+      setResumeSilently(false);
+      setIsUploadModalOpen(true);
     } else {
       onChange(selected);
     }
   };
-
+  
+  useEffect(() => {
+    if (resumeSilently && isUploadModalOpen && modalRef.current) {
+      modalRef.current.triggerResumeAllUploads();
+    }
+  }, [resumeSilently, isUploadModalOpen]);
+  
   return (
     <>
       <StyledSelect
@@ -89,12 +55,16 @@ const GameSelector = ({ games, onChange, value, videoPlayerRef, teamName }) => {
         showTooltip
       />
       <UploadGameModal
-        isOpen={showUploadModal}
+        ref={modalRef} 
+        isOpen={isUploadModalOpen}
         onBeforeOpen={() => videoPlayerRef?.current?.closeControlsOverlay?.()}
-        onClose={() => setShowUploadModal(false)}
+        onClose={() => {
+          setIsUploadModalOpen(false);
+          setResumeSilently(false);
+        }}
         teamName={teamName}
-        incompleteUploadData={incompleteUploadData}
         userId={currentUserId}
+        resumeSilently={resumeSilently}
       />
     </>
   );
diff --git a/frontend/src/components/MainPage.jsx b/frontend/src/components/MainPage.jsx
index eb75132..b3d6e6e 100644
--- a/frontend/src/components/MainPage.jsx
+++ b/frontend/src/components/MainPage.jsx
@@ -29,12 +29,64 @@ const MainPage = () => {
     videoPlayerRef.current?.allowControls();
     setIsUploadModalOpen(false);
   };  
+  const [currentUserId, setCurrentUserId] = useState(false);
+  const [teamName, setTeamName] = useState('');
+  const [showResumeBanner, setShowResumeBanner] = useState(false);
+  const [resumeSilently, setResumeSilently] = useState(false);
+
+  useEffect(() => {
+    const fetchSession = async () => {
+      const { data: { session }, error } = await supabase.auth.getSession();
+      if (error || !session) {
+        console.error('Failed to retrieve user session');
+        return;
+      }
+      const userId = session.user.id;
+      setCurrentUserId(userId);
+    };
+    fetchSession();
+  }, [teamName]);  
+  
+  useEffect(() => {
+    if (!currentUserId) return;
+    const scanIncompleteUploads = () => {
+      const incompleteUploads = [];
+      for (let i = 0; i < localStorage.length; i++) {
+        const key = localStorage.key(i);
+        if (key && key.startsWith('tus::')) {
+          try {
+            const uploadData = JSON.parse(localStorage.getItem(key));
+            if (uploadData?.metadata?.user_id === currentUserId) {
+              incompleteUploads.push({ key, ...uploadData });
+            }
+          } catch (e) {
+            console.error('Error parsing tus entry:', e);
+          }
+        }
+      }
+      if (incompleteUploads.length > 0) {
+        const latestUpload = incompleteUploads.sort((a, b) =>
+          new Date(b.creationTime) - new Date(a.creationTime)
+        )[0];
+        return latestUpload.metadata;
+      }
+
+      return null;
+    };
+    const checkForIncompleteUpload = async () => {
+      const incompleteUploadData = scanIncompleteUploads();
+      if (incompleteUploadData) {
+        setShowResumeBanner(true);
+      }
+    };
+    checkForIncompleteUpload();
+  }, [currentUserId]);  
+  
   const [isAppLoading, setIsAppLoading] = useState(true);
   const videoPlayerRef = useRef(null);
   const [gamePlayers, setGamePlayers] = useState([]);
   const setLocal = (key, value) => localStorage.setItem(key, value);
   const getLocal = (key) => localStorage.getItem(key);
-  const [teamName, setTeamName] = useState('');
   const [availableTeams, setAvailableTeams] = useState([]);
   const [userRole, setUserRole] = useState(null);
   useEffect(() => {
@@ -593,6 +645,11 @@ const MainPage = () => {
               }
             }}
             teamName={teamName}
+            currentUserId={currentUserId}
+            isUploadModalOpen={isUploadModalOpen}
+            setIsUploadModalOpen={setIsUploadModalOpen}
+            setResumeSilently={setResumeSilently}
+            resumeSilently ={resumeSilently }
           />
       </div>
     );
@@ -645,6 +702,11 @@ const MainPage = () => {
                 }}
                 videoPlayerRef={videoPlayerRef}
                 teamName={teamName}
+                currentUserId={currentUserId}
+                isUploadModalOpen={isUploadModalOpen}
+                setIsUploadModalOpen={setIsUploadModalOpen}
+                setResumeSilently={setResumeSilently}
+                resumeSilently ={resumeSilently }
             />     
           </div>
           <div>
@@ -747,6 +809,29 @@ const MainPage = () => {
           </div>
         </div>
       )}
+      {showResumeBanner && (
+        <div className="fixed top-0 left-0 right-0 bg-yellow-100 text-yellow-900 p-3 flex justify-between items-center z-50 shadow">
+          <span>You have an incomplete upload. Would you like to resume it?</span>
+          <div className="space-x-2">
+            <button
+              onClick={() => {
+                setResumeSilently(true);
+                setIsUploadModalOpen(true);
+                setShowResumeBanner(false);
+              }}
+              className="bg-blue-600 text-white px-3 py-1 rounded"
+            >
+              Resume Upload
+            </button>
+            <button
+              onClick={() => setShowResumeBanner(false)}
+              className="bg-gray-300 px-3 py-1 rounded"
+            >
+              Dismiss
+            </button>
+          </div>
+        </div>
+      )}      
     </div>
   </div>
 </div>
diff --git a/frontend/src/components/UploadGameModal.jsx b/frontend/src/components/UploadGameModal.jsx
index 277554a..673ee59 100644
--- a/frontend/src/components/UploadGameModal.jsx
+++ b/frontend/src/components/UploadGameModal.jsx
@@ -1,21 +1,109 @@
-import React, { useState, useEffect, useRef } from 'react';
+import React, { useState, useEffect, useRef, forwardRef, useImperativeHandle, useLayoutEffect  } from 'react';
 import * as tus from 'tus-js-client';
+import { DndContext, closestCenter } from '@dnd-kit/core';
+import { arrayMove, SortableContext, useSortable, verticalListSortingStrategy } from '@dnd-kit/sortable';
+import { CSS } from '@dnd-kit/utilities';
 import FloatingLabelInput from './FloatingLabelInput';
 import Modal from './Modal';
 import Toast from './Toast'; 
 import authorizedFetch from '../utils/authorizedFetch';
 import TooltipPortal from '../utils/tooltipPortal';
 
-const UploadGameModal = ({ isOpen, onBeforeOpen, onClose, teamName, onUpload, incompleteUploadData, userId }) => {
-  const [uploadProgress, setUploadProgress] = useState(0);
+const SortableItem = ({ upload, id, onRemove }) => {
+  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id });
+  const style = {
+    transform: CSS.Transform.toString(transform),
+    transition,
+  };
+
+  return (
+    <div
+      ref={setNodeRef}
+      style={style}
+      {...attributes}
+      {...listeners}  
+      className="flex justify-between items-center px-2 py-1 mb-1 bg-white rounded border border-gray-200 shadow-sm cursor-grab"
+    >
+      <div className="flex items-center min-w-0">
+        <span className="text-gray-400 text-lg mr-2 flex-shrink-0">≡</span>
+        <span className="truncate text-sm">{upload.file.name}</span>
+      </div>
+      <div className="flex items-center flex-shrink-0 ml-2 space-x-2">
+        <span className="text-gray-500 text-xs">Set {upload.setNumber}</span>
+        <button
+          onClick={() => onRemove(upload.id)}
+          onPointerDown={(e) => {
+            e.stopPropagation();
+            e.preventDefault();  
+          }}
+          className="w-6 h-6 flex items-center justify-center rounded-md 
+                    text-gray-500 hover:bg-red-100 transition cursor-pointer"
+        >
+          <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="3">
+            <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
+          </svg>
+        </button>
+      </div>
+    </div>
+  );
+};
+
+const UploadOrderList = ({ uploads, setUploads, onRemove }) => {
+  const handleDragEnd = (event) => {
+    const { active, over } = event;
+    if (active.id !== over.id) {
+      const oldIndex = uploads.findIndex(u => u.id === active.id);
+      const newIndex = uploads.findIndex(u => u.id === over.id);
+
+      const newUploads = arrayMove(uploads, oldIndex, newIndex).map((upload, idx) => ({
+        ...upload,
+        setNumber: idx + 1
+      }));
+
+      setUploads(newUploads);
+    }
+  };
+
+  return (
+    <DndContext collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
+      <div className="space-y-1 mt-2">
+        <SortableContext items={uploads.map(u => u.id)} strategy={verticalListSortingStrategy}>
+          {uploads.map((upload) => (
+            <SortableItem key={upload.id} id={upload.id} upload={upload} onRemove={onRemove} />
+          ))}
+        </SortableContext>
+      </div>
+    </DndContext>
+  );
+};
+
+const UploadGameModal = forwardRef(({ isOpen, onBeforeOpen, onClose, teamName, onUpload, userId, resumeSilently }, ref) => {
+  const [gameGroupId, setGameGroupId] = useState(() => crypto.randomUUID());
+  const [uploads, setUploads] = useState([]);
   const [autofillDate, setAutofillDate] = useState(false);
   const [autofillPlayers, setAutofillPlayers] = useState(false);
   const uploadRef = useRef(null);
+  const [resumeFileHandle, setResumeFileHandle] = useState(null);
   const [isPaused, setIsPaused] = useState(false);
   const [isUploading, setIsUploading] = useState(false);  
-  const [uploadStatus, setUploadStatus] = useState('');
   const [isProgressHovering, setIsProgressHovering] = useState(false);
-  const progressRef = useRef(null);
+  const progressRefs = useRef([]);
+  useEffect(() => {
+    const refs = { ...progressRefs.current };
+    uploads.forEach(upload => {
+      if (!refs[upload.id]) {
+        refs[upload.id] = React.createRef();
+      }
+    });
+    progressRefs.current = refs;
+  }, [uploads]);  
+  const handleRemoveUpload = (id) => {
+    setUploads(prevUploads =>
+      prevUploads
+        .filter(upload => upload.id !== id)
+        .map((upload, idx) => ({ ...upload, setNumber: idx + 1 }))
+    );
+  };  
   const [toastMessage, setToastMessage] = useState('');
   const [toastType, setToastType] = useState('error');
   const [toastDuration, setToastDuration] = useState('error');
@@ -29,21 +117,136 @@ const UploadGameModal = ({ isOpen, onBeforeOpen, onClose, teamName, onUpload, in
   };  
   const [date, setDate] = useState('');
   const [players, setPlayers] = useState('');
-  const [videoFile, setVideoFile] = useState(null);
   const dragCounter = useRef(0);
+  const [incompleteUploadData, setIncompleteUploadData] = useState(null);
+  const customFingerprint = async (file, options) => {
+    if (file instanceof Blob) {
+      const metadata = options.metadata || {};
+      const extraFingerprintData = [
+        metadata.date || '',
+        metadata.players || '',
+        metadata.team_name || '',
+        metadata.user_id || ''
+      ].join('-');
+      return [
+        'tus-br',
+        file.name,
+        file.type,
+        file.size,
+        file.lastModified,
+        options.endpoint,
+        extraFingerprintData
+      ].join('-');
+    }
+    return null;
+  };  
+  const scanIncompleteUploads = () => {
+    const incompleteUploads = [];
 
-  useEffect(() => { 
-    if (incompleteUploadData && !videoFile) {
-    setToast(
-      <>
-        Please select the video file to resume upload:<br />
-        <strong>{incompleteUploadData.filename}</strong>
-      </>,
-      'neutral',
-      10000
-    );
+    for (let i = 0; i < localStorage.length; i++) {
+      const key = localStorage.key(i);
+      if (key && key.startsWith('tus::')) {
+        try {
+          const uploadData = JSON.parse(localStorage.getItem(key));
+          if (uploadData?.metadata?.user_id === userId) {
+            incompleteUploads.push({ key, ...uploadData });
+          }
+        } catch (e) {
+          console.error('Error parsing tus entry:', e);
+        }
+      }
+    }
+    return incompleteUploads;
+  };
+
+  const loadAllResumableUploads = async () => {
+    const incompleteUploads = scanIncompleteUploads();
+    const resumableUploads = [];
+
+    for (const upload of incompleteUploads) {
+      const fileHandle = await getFileHandleFromIndexedDB(upload.key);
+      if (fileHandle) {
+        resumableUploads.push({ key: upload.key, uploadData: upload, fileHandle });
+      }
+    }
+    return resumableUploads;
+  };
+  
+  const getNextSetNumber = (uploads) => {
+    const existingNumbers = uploads.map(u => u.setNumber).filter(Boolean);
+    let num = 1;
+    while (existingNumbers.includes(num)) {
+      num++;
+    }
+    return num;
+  };  
+  
+  useImperativeHandle(ref, () => ({
+    triggerResumeAllUploads: async () => {
+      const resumableUploads = await loadAllResumableUploads();
+      if (resumableUploads.length === 0) {
+        setToast('No resumable uploads found', 'error');
+        return;
+      }
+      for (const { key, uploadData, fileHandle } of resumableUploads) {
+        try {
+          if (!fileHandle || typeof fileHandle.requestPermission !== 'function') {
+            console.error('Invalid file handle structure', fileHandle);
+            setToast(`Failed to resume ${uploadData.metadata.filename}`, 'error');
+            await removeFileHandleFromIndexedDB(key);
+            localStorage.removeItem(key);
+            continue;
+          }
+          const permission = await fileHandle.requestPermission();
+          if (permission === 'granted') {
+            try {
+              const file = await fileHandle.getFile();
+              const metadata = uploadData.metadata;
+              if (metadata.date) {
+                setDate(metadata.date);
+                setAutofillDate(true);
+              }
+              if (metadata.players) {
+                setPlayers(metadata.players);
+                setAutofillPlayers(true);
+              }
+              const fingerprint = await customFingerprint(file, {
+                endpoint: '/api/upload-game',
+                metadata
+              });              
+              setUploads(prev => [
+                ...prev,
+                {
+                  file,
+                  progress: 0,
+                  status: 'pending',
+                  paused: false,
+                  uploadRef: null,
+                  fileHandle,
+                  id: fingerprint,
+                  setNumber: parseInt(uploadData.metadata.setNumber, 10)
+                }
+              ]);
+              setToast(`Resumed upload for ${file.name}`, 'success');
+              setTimeout(() => {
+                handleSubmit(fingerprint, file, metadata.date, metadata.players, fingerprint);
+              }, 0);
+            } catch (fileError) {
+              console.error('Failed to get file from handle', fileError);
+              setToast(`Could not access file ${uploadData.metadata.filename}. Try again later.`, 'error');
+            }
+          } else {
+            setToast(`Permission denied for ${uploadData.metadata.filename}`, 'error');
+            await removeFileHandleFromIndexedDB(key);
+            localStorage.removeItem(key);
+          }
+        } catch (err) {
+          console.error('Unexpected resume failure', err);
+          setToast(`Unexpected failure while resuming ${uploadData.metadata.filename}`, 'error');
+        }
+      }
     }
-  }, [incompleteUploadData, videoFile]);
+  }));
 
   useEffect(() => {
     if (incompleteUploadData) {
@@ -58,155 +261,407 @@ const UploadGameModal = ({ isOpen, onBeforeOpen, onClose, teamName, onUpload, in
     }
   }, [incompleteUploadData]);
   
-  const handleFileSelect = (e) => {
-    const file = e.target.files[0];
-    if (file) {
-      if (file.type === 'video/mp4') {
-        setVideoFile(file);
-      } else {
-        setToast('Only MP4 video files are supported');
-        e.target.value = '';
-      }
+  const currentFileHandleRef = useRef(null);
+  const handleFileSelect = async () => {
+    if (uploads.length >= 5) {
+      setToast('Maximum of 5 video files allowed', 'error');
+      return;
+    }    
+    if (!window.showOpenFilePicker) {
+      setToast('Your browser does not support persistent file access', 'error');
+      return;
     }
-  };
 
-  const handlePauseResume = () => {
-    if (!uploadRef.current) return;
+    try {
+      const fileHandles = await window.showOpenFilePicker({
+        types: [{ description: 'MP4 Videos', accept: { 'video/mp4': ['.mp4'] } }],
+        excludeAcceptAllOption: true,
+        multiple: true,
+      });
+      const newUploads = [];
+      let duplicateCount = 0;
+      let invalidCount = 0;  
+      for (const fileHandle of fileHandles) {
+        const file = await fileHandle.getFile();
+        if (file.type !== 'video/mp4') {
+          invalidCount++;
+          continue;
+        }
+        const metadata = {
+          filename: file.name,
+          filetype: file.type,
+          date,
+          players,
+          team_name: teamName,
+          user_id: userId,
+          game_group_id: gameGroupId,
+          setNumber: (uploads.length + 1).toString()
+        };
+        const fingerprint = await customFingerprint(file, { endpoint: '/api/upload-game', metadata });            
+        if (uploads.some(u => u.file.name === file.name) || newUploads.some(u => u.file.name === file.name)) {
+          duplicateCount++;
+          continue;
+        }
+        newUploads.push({
+          file,
+          progress: 0,
+          status: 'pending',
+          paused: false,
+          uploadRef: null,
+          fileHandle,
+          id: fingerprint,
+          setNumber: getNextSetNumber([...uploads, ...newUploads])
+        });
+      }
+      if (invalidCount > 0) {
+        setToast(`${invalidCount} invalid file(s) skipped (only MP4 allowed)`, 'error');
+      }
+      if (newUploads.length === 0) {
+        if (duplicateCount === 0 && invalidCount > 0) {
+          setToast('No valid MP4 files selected', 'error');
+        }
+        return;
+      }
+      const remainingSlots = 5 - uploads.length;
+      const uploadsToAdd = newUploads.slice(0, remainingSlots);
+      setUploads(prev => [...prev, ...uploadsToAdd]);
 
-    if (isPaused) {
-      uploadRef.current.start();
-      setIsPaused(false);
-    } else {
-      uploadRef.current.abort();
-      setIsPaused(true);
+      if (uploadsToAdd.length < newUploads.length) {
+        setToast('Only 5 files allowed. Some were not added.', 'error');
+      }
+    } catch (err) {
+      console.error('File selection cancelled or failed', err);
     }
   };
 
-  const handleSubmit = async () => {
-    const customFingerprint = async (file, options) => {
-      if (file instanceof Blob) {
-        const metadata = options.metadata || {};
-
-        const extraFingerprintData = [
-          metadata.date || '',
-          metadata.players || '',
-          metadata.team_name || '',
-          metadata.user_id || ''
-        ].join('-');
-
-        return [
-          'tus-br',
-          file.name,
-          file.type,
-          file.size,
-          file.lastModified,
-          options.endpoint,
-          extraFingerprintData
-        ].join('-');
-      }
+  function openIndexedDB() {
+    return new Promise((resolve, reject) => {
+      const request = indexedDB.open('upload-files-db', 1);
+      request.onupgradeneeded = (event) => {
+        const db = event.target.result;
+        if (!db.objectStoreNames.contains('file-handles')) {
+          db.createObjectStore('file-handles');
+        }
+      };
+      request.onsuccess = (event) => resolve(event.target.result);
+      request.onerror = (event) => reject(event.target.error);
+    });
+  }
 
-      return null;
-    };
-    
-    if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
-      setToast('Date format should be YYYY-MM-DD');
-      return;
-    }
-    if (!players.trim()) {
-      setToast('Please enter players (comma-separated)');
-      return;
-    }    
-    if (!videoFile) {
-      setToast('Please select a video file');
-      return;
-    }
-    if (videoFile.type !== 'video/mp4') {
-      setToast('Only MP4 video files are supported');
-      return;
-    }
-    setIsUploading(true);  
-    setIsPaused(false);
-    setUploadProgress(0);
-    onClose();
-    const upload = new tus.Upload(videoFile, {
-      endpoint: '/api/upload-game',
-      retryDelays: [0, 1000, 3000, 5000],
-      metadata: {
-        filename: videoFile.name,
-        filetype: videoFile.type,
-        date,
-        players,
-        team_name: teamName,
-        user_id: userId
-      },
-      fingerprint: customFingerprint,
-      removeFingerprintOnSuccess: true,
-      onError: (error) => {
-        console.error('Upload failed:', error);
-        setIsUploading(false);
-        setToast('Upload failed');
-      },
-      onProgress: (bytesUploaded, bytesTotal) => {
-        const percentage = Math.floor((bytesUploaded / bytesTotal) * 100);
-        setUploadProgress(percentage);
-        if (upload.url && !uploadRef.current?.url) {
-          uploadRef.current.url = upload.url;
-        }        
-      },
-      onSuccess: async () => {
-        setIsUploading(false);
-        setUploadStatus('success');
-        setToast('Game uploaded successfully!', 'success');
-      }
+  async function saveFileHandleToIndexedDB(fileHandle, key) {
+    const db = await openIndexedDB();
+    const tx = db.transaction('file-handles', 'readwrite');
+    const store = tx.objectStore('file-handles');
+    store.put(fileHandle, key);
+    return new Promise((resolve) => {
+      tx.oncomplete = () => {
+        db.close();
+        resolve();
+      };
     });
+  }
 
-    upload.findPreviousUploads().then((previousUploads) => {
-      if (previousUploads.length > 0) {
-        upload.resumeFromPreviousUpload(previousUploads[0]);
-      }
-      upload.start();
+  async function getFileHandleFromIndexedDB(key) {
+    const db = await openIndexedDB();
+    const tx = db.transaction('file-handles', 'readonly');
+    const store = tx.objectStore('file-handles');
+    return new Promise((resolve, reject) => {
+      const request = store.get(key);
+      request.onsuccess = (event) => resolve(event.target.result);
+      request.onerror = (event) => reject(event.target.error);
     });
+  }
 
-    uploadRef.current = upload;
-  };
+  async function removeFileHandleFromIndexedDB(key) {
+    const db = await openIndexedDB();
+    const tx = db.transaction('file-handles', 'readwrite');
+    const store = tx.objectStore('file-handles');
+    store.delete(key);
+    return new Promise((resolve) => {
+      tx.oncomplete = () => {
+        db.close();
+        resolve();
+      };
+    });
+  }
+
+  useEffect(() => {
+    const tryLoadFileHandle = async () => {
+      const incompleteUploads = scanIncompleteUploads();
+      if (incompleteUploads.length === 0) return;
+      for (const upload of incompleteUploads) {
+        const fileHandle = await getFileHandleFromIndexedDB(upload.key);
+        if (fileHandle) {
+          setResumeFileHandle(fileHandle);
+          break;
+        }
+      }
+    };
+    tryLoadFileHandle();
+  }, []);
 
-  const cancelUpload = async () => {
-    if (uploadRef.current) {
-      const uploadUrl = uploadRef.current.url;
-      if (uploadUrl) {
-        const uploadId = uploadUrl.split('/').pop();
+  useEffect(() => {
+    if (resumeFileHandle && isOpen) {
+      (async () => {
         try {
-          const res = await authorizedFetch(`/api/delete-upload/${uploadId}`, {
-            method: 'DELETE'
-          });
-          if (!res.ok) {
-            const errorData = await res.json().catch(() => ({ message: 'No response body' }));
-            console.error('Failed to delete upload on server:', errorData.message || errorData);
-          } else {
-            const successData = await res.json().catch(() => ({}));
+          const permission = await resumeFileHandle.requestPermission();
+          if (permission !== 'granted') {
+            setToast('Permission denied. Please re-select the file.', 'error');
+            await removeFileHandleFromIndexedDB();
+            setResumeFileHandle(null);
+            return;
           }
+          const file = await resumeFileHandle.getFile();
+          let uploadData = null;
+          for (let i = 0; i < localStorage.length; i++) {
+            const key = localStorage.key(i);
+            if (key && key.startsWith('tus::')) {
+              const data = JSON.parse(localStorage.getItem(key));
+              if (data && data.metadata?.filename === file.name && data.metadata?.user_id === userId) {
+                uploadData = data;
+                break;
+              }
+            }
+          }
+          if (!uploadData) {
+            setToast('Could not find upload metadata for this file.', 'error');
+            await removeFileHandleFromIndexedDB();
+            setResumeFileHandle(null);
+            return;
+          }          
+          const metadata = {
+            filename: file.name,
+            filetype: file.type,
+            date,
+            players,
+            team_name: teamName,
+            user_id: userId,
+            game_group_id: gameGroupId,
+            setNumber: parseInt(uploadData.metadata.setNumber, 10)
+          };
+          const fingerprint = await customFingerprint(file, { endpoint: '/api/upload-game', metadata });
+          const newUpload = {
+            file,
+            progress: 0,
+            status: 'pending',
+            paused: false,
+            uploadRef: null,
+            fileHandle: resumeFileHandle,
+            id: fingerprint,
+            setNumber: parseInt(uploadData.metadata.setNumber, 10)
+          };
+          setUploads(prev => [...prev, newUpload]);
+          setResumeFileHandle(null);
+          onClose();
+          setToast('Resumed upload from previous session', 'success');
+          setTimeout(() => {
+            handleSubmit(newUpload.id);
+          }, 0);
         } catch (err) {
-          console.error('Error deleting upload:', err);
+          console.error('Failed to resume file handle', err);
+          setToast('Failed to resume file handle', 'error');
+          await removeFileHandleFromIndexedDB();
+          setResumeFileHandle(null);
         }
+      })();
+    }
+  }, [resumeFileHandle, isOpen]);
+
+  const handleResumeUpload = async () => {
+    if (!resumeFileHandle) return;
+
+    try {
+      const permission = await resumeFileHandle.requestPermission();
+      if (permission === 'granted') {
+        const file = await resumeFileHandle.getFile();
+        setVideoFile(file);
+        setResumeFileHandle(null);  // Clear resume state
+        if (!resumeSilently) {
+          onClose();
+        }
+        setToast('Resumed upload from previous session', 'success');
+        handleSubmit(file);
+      } else {
+        setToast('Permission denied. Please re-select the file.', 'error');
+        await removeFileHandleFromIndexedDB();
+        setResumeFileHandle(null);
       }
+    } catch (err) {
+      console.error('Failed to resume file handle', err);
+      setToast('Failed to resume file handle', 'error');
+      await removeFileHandleFromIndexedDB();
+      setResumeFileHandle(null);
     }
-    uploadRef.current.abort();
-    setUploadStatus('cancelled');
-    setIsUploading(false);
   };
 
-  useEffect(() => {
-    if (uploadStatus === 'success' || uploadStatus === 'error' || uploadStatus === 'cancelled') {
-      const timeout = setTimeout(() => {
-        setUploadStatus('');
-      }, 5000); // Hide after 5 seconds
-      return () => clearTimeout(timeout);
+  const togglePauseResume = (uploadId) => {
+    const index = uploads.findIndex(u => u.id === uploadId);
+    if (index === -1) return;
+
+    const uploadItem = uploads[index];
+    const uploadRef = uploadItem.uploadRef;
+    if (!uploadRef) return;
+
+    if (uploadItem.paused) {
+      uploadRef.findPreviousUploads().then((previousUploads) => {
+        if (previousUploads.length) {
+          uploadRef.resumeFromPreviousUpload(previousUploads[0]);
+        }
+        uploadRef.start();
+
+        setUploads(prev => {
+          const updated = [...prev];
+          if (updated[index]) {
+            updated[index].paused = false;
+            updated[index].status = 'uploading';
+          }
+          return updated;
+        });
+      });
+    } else {
+      uploadRef.abort();
+      setUploads(prev => {
+        const updated = [...prev];
+        if (updated[index]) {
+          updated[index].paused = true;
+          updated[index].status = 'paused';
+        }
+        return updated;
+      });
+    }
+  };
+
+  const cancelUpload = async (uploadId) => {
+    const uploadIndex = uploads.findIndex(u => u.id === uploadId);
+    if (uploadIndex === -1) return;
+
+    const upload = uploads[uploadIndex];
+    if (!upload || !upload.uploadRef) return;
+
+    upload.uploadRef.abort();
+    const uploadUrl = upload.uploadRef.url;
+    if (uploadUrl) {
+      const tusUploadId = uploadUrl.split('/').pop();
+      try {
+        const res = await authorizedFetch(`/api/delete-upload/${tusUploadId}`, {
+          method: 'DELETE'
+        });
+        if (!res.ok) {
+          const errorData = await res.json().catch(() => ({ message: 'No response body' }));
+          console.error('Failed to delete upload on server:', errorData.message || errorData);
+        }
+      } catch (err) {
+        console.error('Error deleting upload:', err);
+      }
+      for (let i = 0; i < localStorage.length; i++) {
+        const key = localStorage.key(i);
+        if (key && key.startsWith('tus::')) {
+          const data = JSON.parse(localStorage.getItem(key));
+          if (data && data.metadata?.user_id === userId && data.metadata?.filename === upload.file.name){
+            localStorage.removeItem(key);
+            await removeFileHandleFromIndexedDB(key);
+            break;
+          }
+        }
+      }
+      setUploads(prev => prev.filter(u => u.id !== uploadId));
+    }
+  };
+
+const handleSubmit = async (uploadId, fileOverride = null, dateOverride = null, playersOverride = null, tusKeyOverride = null) => {
+  const uploadItem = uploads.find(u => u.id === uploadId);
+  if (!uploadItem && !fileOverride) {
+    setToast('No file selected for upload');
+    return;
+  }
+  const fileToUpload = fileOverride || uploadItem.file;
+  const dateToUse = dateOverride || date;
+  const playersToUse = playersOverride || players;
+  if (!/\d{4}-\d{2}-\d{2}/.test(dateToUse)) {
+    setToast('Date format should be YYYY-MM-DD');
+    return 'validation-error';
+  }
+  if (!playersToUse.trim()) {
+    setToast('Please enter players (comma-separated)');
+    return 'validation-error';
+  }
+
+  let fileHandleSaved = false;
+
+  const upload = new tus.Upload(fileToUpload, {
+    endpoint: '/api/upload-game',
+    retryDelays: [0, 1000, 3000, 5000],
+    metadata: {
+      filename: fileToUpload.name,
+      filetype: fileToUpload.type,
+      date: dateToUse,
+      players: playersToUse,
+      team_name: teamName,
+      user_id: userId,
+      game_group_id: gameGroupId,
+      setNumber: uploadItem?.setNumber?.toString() || '1'
+    },
+    fingerprint: customFingerprint,
+    onError: (error) => {
+      console.error('Upload failed:', error);
+      setUploads(prev => prev.map(u => u.id === uploadId ? { ...u, status: 'error' } : u));
+      setToast('Upload failed');
+    },
+    onProgress: async (bytesUploaded, bytesTotal) => {
+      const percentage = Math.floor((bytesUploaded / bytesTotal) * 100);
+      setUploads(prev => prev.map(u => (u.id === uploadId ? { ...u, progress: percentage } : u)));
+
+      if (!fileHandleSaved && uploadItem?.fileHandle) {
+        for (let i = 0; i < localStorage.length; i++) {
+          const key = localStorage.key(i);
+          if (key && key.startsWith('tus::')) {
+            const data = JSON.parse(localStorage.getItem(key));
+            if (data && data.metadata?.user_id === userId && data.metadata?.filename === fileToUpload.name) {
+              await saveFileHandleToIndexedDB(uploadItem.fileHandle, key);
+              fileHandleSaved = true;
+              break;
+            }
+          }
+        }
+      }
+    },
+    onSuccess: async () => {
+      setUploads(prev => prev.map(u => (u.id === uploadId ? { ...u, status: 'success' } : u)));
+      setToast('Game uploaded successfully!', 'success');
+      setTimeout(() => {
+        setUploads(prev => prev.filter(u => u.id !== uploadId));
+      }, 5000);
+      for (let i = 0; i < localStorage.length; i++) {
+        const key = localStorage.key(i);
+        if (key && key.startsWith('tus::')) {
+          const data = JSON.parse(localStorage.getItem(key));
+          if (data && data.metadata?.user_id === userId && data.metadata?.filename === fileToUpload.name) {
+            localStorage.removeItem(key);
+            await removeFileHandleFromIndexedDB(key);
+            break;
+          }
+        }
+      }
     }
-  }, [uploadStatus]);
+  });
 
+  setUploads(prev => prev.map(u => (u.id === uploadId ? { ...u, uploadRef: upload, status: 'uploading' } : u)));
+
+  upload.findPreviousUploads().then((previousUploads) => {
+    if (previousUploads.length > 0) {
+      upload.resumeFromPreviousUpload(previousUploads[0]);
+    }
+    upload.start();
+  });
+};
+  
   useEffect(() => {
-    if (isOpen && onBeforeOpen) {
-      onBeforeOpen();
+    if (isOpen) {
+      setGameGroupId(crypto.randomUUID()); 
+      setUploads([]); 
+      if (onBeforeOpen) {
+        onBeforeOpen();
+      }
     }
   }, [isOpen, onBeforeOpen]);
 
@@ -223,8 +678,34 @@ const UploadGameModal = ({ isOpen, onBeforeOpen, onClose, teamName, onUpload, in
     };
   }, [isOpen]);
 
+  useEffect(() => {
+    const refs = { ...progressRefs.current };
+    uploads.forEach(upload => {
+      if (!refs[upload.id]) {
+        refs[upload.id] = React.createRef();
+      }
+    });
+    progressRefs.current = refs;
+  }, [uploads]);
+
+  const [tooltipPosition, setTooltipPosition] = useState({ top: 0, left: 0 });
+
+  useLayoutEffect(() => {
+    if (isProgressHovering) {
+      const ref = progressRefs.current[isProgressHovering]?.current;
+      if (ref) {
+        const rect = ref.getBoundingClientRect();
+        setTooltipPosition({
+          top: rect.bottom + 8,
+          left: rect.left + rect.width / 2
+        });
+      }
+    }
+  }, [isProgressHovering, uploads]);
+
   return (
     <>
+    {!resumeSilently && (
       <Modal isOpen={isOpen} onClose={onClose}>
         <div className="text-center">
           <h2 className="text-xl font-semibold mb-2">Upload New Game</h2>
@@ -259,7 +740,7 @@ const UploadGameModal = ({ isOpen, onBeforeOpen, onClose, teamName, onUpload, in
         />
         {/* Drag & Drop*/}
         <div
-          className={`mt-6 border-2 border-dashed border-gray-300 rounded-lg py-12 px-6 text-center relative transition-all ${
+          className={`mt-6 border-2 border-dashed border-gray-300 rounded-lg px-6 pt-4 pb-4 text-center relative transition-all ${
             isDragging ? 'border-blue-500 ring-2 ring-blue-300' : ''
           }`}
           onDragEnter={(e) => {
@@ -278,113 +759,178 @@ const UploadGameModal = ({ isOpen, onBeforeOpen, onClose, teamName, onUpload, in
             e.preventDefault();
             e.dataTransfer.dropEffect = 'copy';
           }}
-          onDrop={(e) => {
+          onDrop={async (e) => {
             e.preventDefault();
             dragCounter.current = 0;
             setIsDragging(false);
-            const file = e.dataTransfer.files[0];
-            if (file && file.type === 'video/mp4') {
-              setVideoFile(file);
-            } else {
-              setToast('Only MP4 video files are supported');
+
+            const files = Array.from(e.dataTransfer.files);
+            const validFiles = [];
+            let invalidCount = 0;
+
+            for (const file of files) {
+              if (file.type === 'video/mp4') {
+                const metadata = {
+                  filename: file.name,
+                  filetype: file.type,
+                  date,
+                  players,
+                  team_name: teamName,
+                  user_id: userId,
+                  game_group_id: gameGroupId,
+                  setNumber: (uploads.length + validFiles.length + 1).toString()
+                };
+                const fingerprint = await customFingerprint(file, { endpoint: '/api/upload-game', metadata });
+
+                validFiles.push({
+                  file,
+                  progress: 0,
+                  status: 'pending',
+                  paused: false,
+                  uploadRef: null,
+                  fileHandle: null,
+                  id: fingerprint,
+                  setNumber: getNextSetNumber([...uploads, ...validFiles])
+                });
+              } else {
+                invalidCount++;
+              }
+            }
+
+            if (invalidCount > 0) {
+              setToast(`${invalidCount} invalid file(s) skipped (only MP4 allowed)`, 'error');
+            }
+
+            const remainingSlots = 5 - uploads.length;
+            const uploadsToAdd = validFiles.slice(0, remainingSlots);
+            setUploads(prev => [...prev, ...uploadsToAdd]);
+
+            if (uploadsToAdd.length < validFiles.length) {
+              setToast('Only 5 files allowed. Some were not added.', 'error');
             }
           }}
         >
-          <p className="text-lg font-semibold mb-1">Drag and drop a video file to upload</p>
-          <p className="text-sm text-gray-500 mb-4">Your video will take some time to process before it's available.</p>
-          <input
-            type="file"
-            accept="video/mp4"
-            onChange={handleFileSelect}
-            className="hidden"
-            id="fileUpload"
-          />
-          <label
-            htmlFor="fileUpload"
-            className="inline-block px-6 py-2 bg-white border border-gray-300 rounded-md font-semibold text-sm cursor-pointer hover:bg-gray-100"
-          >
-            Select file
-          </label>
-          <div className="mt-2 h-5 overflow-hidden text-ellipsis whitespace-nowrap text-sm text-gray-700">
-            {videoFile ? videoFile.name : '\u00A0'}
+        <p className="text-lg font-semibold mb-1">Drag and drop a video file to upload</p>
+        <p className="text-sm text-gray-500 mb-4">Your video will take some time to process before it's available.</p>
+        <button
+          onClick={handleFileSelect}
+          className="inline-block px-6 py-2 bg-white border border-gray-300 rounded-md font-semibold text-sm cursor-pointer hover:bg-gray-100"
+        >
+          Select file(s)
+        </button>
+        {uploads.filter(upload => upload.status === 'pending').length > 0 && (
+          <div className="mt-4 space-y-1">
+            <UploadOrderList uploads={uploads.filter(u => u.status === 'pending')} setUploads={setUploads} onRemove={handleRemoveUpload} />
           </div>
-        </div>
-        {/* Bottom buttons */}
-        <div className="mt-6 flex justify-between">
-          <button onClick={onClose} className="px-4 py-2 border border-gray-300 rounded-md hover:bg-gray-100">Cancel</button>
-          <button onClick={handleSubmit} className="px-4 py-2 bg-black text-white rounded-md hover:bg-gray-800">Upload Game</button>
-        </div>
-      </Modal>
-      <Toast
-        message={toastMessage}
-        show={showToast}
-        duration={toastDuration}
-        onClose={() => setShowToast(false)}
-        type={toastType}
-      />
-      {(isUploading || uploadStatus) && (
-        <div className="fixed top-0 right-4 transform h-14 flex items-center z-50">
-          <div className="flex items-center px-4 py-2 bg-white shadow-xl rounded-xl border border-gray-200 pointer-events-auto w-94">
-            <div
-              className="w-40 h-2 bg-gray-200 rounded-full overflow-hidden relative"
-              ref={progressRef}
-              onMouseEnter={() => setIsProgressHovering(true)}
-              onMouseLeave={() => setIsProgressHovering(false)}
-            >
-              <div
-                className={`
-                  h-full transition-all duration-300 ease-out
-                  ${uploadStatus === 'success' ? 'bg-green-500' :
-                    (uploadStatus === 'error' || uploadStatus === 'cancelled') ? 'bg-red-500' :
-                    'bg-gradient-to-r from-blue-500 to-blue-600'
-                  }
-                `}
-                style={{ width: `${uploadProgress}%` }}
-              ></div>
-            </div>
-            <div className="flex-grow flex justify-end items-center ml-3">
-              <span className="text-sm font-medium text-gray-700">
-                {uploadStatus === 'success' && 'Done'}
-                {uploadStatus === 'error' && 'Failed'}
-                {uploadStatus === 'cancelled' && 'Cancelled'}
-                {isUploading && `${isPaused ? 'Paused' : 'Uploading'}... ${uploadProgress}%`}
-              </span>
-              {isUploading && (
-                <>
-                  <button className="ml-1 w-6 h-6 cursor-pointer rounded-md hover:bg-gray-100" onClick={handlePauseResume}>
-                    {isPaused ? (
-                      <svg viewBox="0 0 36 36" width="100%" height="100%" fill="black">
-                        <path d="M 12,10 L 25,18 L 12,26 Z" />
-                      </svg>
-                    ) : (
-                      <svg viewBox="0 0 36 36" width="100%" height="100%" fill="black">
-                        <path d="M 12,10 L 16,10 L 16,26 L 12,26 Z M 20,10 L 24,10 L 24,26 L 20,26 Z" />
+        )}
+      </div>
+      {/* Bottom buttons */}
+      <div className="mt-6 flex justify-between">
+        <button onClick={onClose} className="px-4 py-2 border border-gray-300 rounded-md hover:bg-gray-100">Cancel</button>
+        <button
+          onClick={async () => {
+            let hasValidationErrors = false;
+
+            for (let index = 0; index < uploads.length; index++) {
+              const upload = uploads[index];
+              if (upload.status === 'pending') {
+                const result = await handleSubmit(upload.id);
+                if (result === 'validation-error') {
+                  hasValidationErrors = true;
+                }
+              }
+            }
+
+            if (!hasValidationErrors) {
+              onClose();
+            }
+          }}
+          className="px-4 py-2 bg-black text-white rounded-md hover:bg-gray-800"
+        >
+          Upload Game(s)
+        </button>
+      </div>       
+    </Modal>
+  )}
+    <Toast
+      message={toastMessage}
+      show={showToast}
+      duration={toastDuration}
+      onClose={() => setShowToast(false)}
+      type={toastType}
+    />
+    {uploads.length > 0 && uploads.some(u => u.status !== 'pending') && (
+      <div className="fixed top-4 right-4 w-96 bg-white shadow-2xl rounded-xl p-4 z-50">
+        {uploads
+          .filter(upload => upload.status !== 'pending' && upload.id)
+          .map((upload) => (
+            <div key={upload.id} className="flex items-center mb-2 last:mb-0 w-full">
+              <div className="relative w-40 h-4 bg-gray-200 rounded-full overflow-hidden"
+                ref={progressRefs.current[upload.id]}
+                onMouseEnter={() => setIsProgressHovering(upload.id)}
+                onMouseLeave={() => setIsProgressHovering(null)}
+              >              
+                <div
+                  className={`
+                    absolute top-0 left-0 h-full
+                    ${upload.status === 'success' ? 'bg-green-500' :
+                      (upload.status === 'error' || upload.status === 'cancelled') ? 'bg-red-500' :
+                      'bg-gradient-to-r from-blue-500 to-blue-600'
+                    }
+                  `}
+                  style={{ width: `${upload.progress}%` }}
+                ></div>
+                <div className="absolute inset-0 flex items-center justify-center text-xs font-medium text-black opacity-55 pointer-events-none">
+                  Set {upload.setNumber}
+                </div>
+              </div>              
+              <div className="flex-grow flex justify-end items-center ml-3">
+                <span className="text-sm font-medium text-gray-700 mr-2">
+                  {upload.status === 'success' && 'Done'}
+                  {upload.status === 'error' && 'Failed'}
+                  {upload.status === 'cancelled' && 'Cancelled'}
+                  {(upload.status === 'uploading' || upload.status === 'paused') && `${upload.paused ? 'Paused' : 'Uploading'}... ${upload.progress}%`}
+                </span>
+                {(upload.status === 'uploading' || upload.status === 'paused') && (
+                  <>
+                    <button
+                      onClick={() => togglePauseResume(upload.id)}
+                      className="w-6 h-6 mr-1 cursor-pointer rounded-md hover:bg-gray-100"
+                    >
+                      {upload.paused ? (
+                        <svg viewBox="0 0 36 36" width="100%" height="100%" fill="black">
+                          <path d="M 12,10 L 25,18 L 12,26 Z" />
+                        </svg>
+                      ) : (
+                        <svg viewBox="0 0 36 36" width="100%" height="100%" fill="black">
+                          <path d="M 12,10 L 16,10 L 16,26 L 12,26 Z M 20,10 L 24,10 L 24,26 L 20,26 Z" />
+                        </svg>
+                      )}
+                    </button>
+                    <button
+                      onClick={() => cancelUpload(upload.id)}
+                      className="w-6 h-6 flex items-center justify-center rounded-md 
+                                text-gray-500 
+                                hover:bg-red-100 transition cursor-pointer"
+                    >
+                      <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="3">
+                        <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                       </svg>
-                    )}
-                  </button>
-                  <button
-                    onClick={cancelUpload}
-                    className="w-6 h-6 flex items-center justify-center rounded-md 
-                              text-gray-500 
-                              hover:bg-red-100 transition cursor-pointer"
-                  >
-                    <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="3">
-                      <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
-                    </svg>
-                  </button>
-                </>
-              )}
+                    </button>
+                  </>
+                )}
+              </div>
             </div>
-          </div>
-        </div>
-      )}
-      {isProgressHovering && videoFile && (
+          ))}
+      </div>
+    )}
+      {isProgressHovering && uploads.find(u => u.id === isProgressHovering) && (
         <TooltipPortal>
           <div
             style={{
               position: 'fixed',
-              top: progressRef.current?.getBoundingClientRect().bottom + 8,
-              left: (progressRef.current?.getBoundingClientRect().left || 0) + (progressRef.current?.offsetWidth / 2 || 0),
+              top: tooltipPosition.top,
+              left: tooltipPosition.left,
               transform: 'translateX(-50%)',
               background: 'rgba(0,0,0,0.8)',
               color: 'white',
@@ -396,12 +942,12 @@ const UploadGameModal = ({ isOpen, onBeforeOpen, onClose, teamName, onUpload, in
               zIndex: 9999
             }}
           >
-            Uploading {videoFile.name}
+            Uploading {uploads.find(u => u.id === isProgressHovering)?.file.name}
           </div>
         </TooltipPortal>
-      )}      
+      )}
     </>
   );
-};
+});
 
-export default UploadGameModal;
+export default UploadGameModal;
\ No newline at end of file
diff --git a/frontend/vite.config.js b/frontend/vite.config.js
index a086d4d..cde3d74 100644
--- a/frontend/vite.config.js
+++ b/frontend/vite.config.js
@@ -43,4 +43,4 @@ export default defineConfig({
       react: path.resolve('./node_modules/react'),
     },     
   },
-});           
\ No newline at end of file
+});            
\ No newline at end of file
diff --git a/tus/tusserver.js b/tus/tusserver.js
index 241cc4d..3bcc5ec 100644
--- a/tus/tusserver.js
+++ b/tus/tusserver.js
@@ -19,15 +19,24 @@ const tusServer = new Server({
   respectForwardedHeaders: true,
   generateUrl: (req, { id, path }) => {
     return `${path}/${id}`;
+  }  ,
+  namingFunction: (req, metadata) => {
+    const dateStr = metadata.date || 'unknown-date';
+    const gameGroupId = metadata.game_group_id || 'unknown-group';
+    const originalFilename = metadata.filename || 'unnamed';
+    const setnumber = metadata.setNumber || 'unnamed';
+    const ext = path.extname(originalFilename) || '.mp4';
+    const finalFileName = `${gameGroupId}_SET-${setnumber}_READY${ext}`;
+    console.log(`Saving upload as: ${finalFileName}`);
+    return finalFileName;
+  },
+  async onUploadFinish(req, res, upload) {
+    console.log(`✅ Upload finished and saved as: ${upload.id}`);
+    // You can add Supabase DB operations here if needed.
+    return { status_code: 204 };
   }
 });
 
-
-tusServer.on(EVENTS.POST_FINISH, (req, res, upload) => {
-  console.log('Upload finished:', upload.id);
-  // You can add file renaming/moving logic here if needed.
-});
-
 const options = {
   key: fs.readFileSync('./cert/key.pem'),
   cert: fs.readFileSync('./cert/cert.pem'),
